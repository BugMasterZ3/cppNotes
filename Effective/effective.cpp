

/**************************************effictive*******************************/
// 一、Contents (DialyLog):
// 优秀的异常设计(客户端操作/非析构函数 + 析构函数捕获(失败将回到终止或吞咽))
// 派生类与基类转换问题(显式与隐式(dynamic_cast横/侧向转换规则)、指针与引用、智能指针)
// RAII资源管理类(智能指针+析构释放)：api访问原始资源(显式转换更安全，隐式转换更方便客户端)
// 引用传递机制(切割问题)
// 延后变量定义至明显意义初值，避免无意义默认构造
// 模板代码膨胀问题及解决方案、编译依存性
// 遮掩继承条款
// 区分接口继承与实现继承(pure/impure/non_virtual,NVI手法)
// 深入了解non_virtual函数(不要重新定义)
// 静态绑定与动态绑定
// classes(显式接口+运行期多态)、templates(隐式接口+编译期多态)
// 整合重载技术使在编译期间执行if...else测试
// 模板元编程(结构体递归求阶乘)

typedef void (*new_handler)();
new_handler set_new_handler(new handler p)	throw ();	//返回函数的函数

// 二、易错点归纳：
// 尽量使用const、enum、inline等代替#define，因为#define可能会导致一些不可预期的问题，比如符号重定义、类型不匹配等问题
// 构造函数的实参可以通过隐式类型转换来匹配对应的形参类型。但如果构造函数的形参不是const引用类型，那么这种隐式类型转换可能会导致不必要的构造函数调用和内存分配
// 在函数声明中，应该尽量避免使用与内置类型等效的默认参数，因为这样可能会导致调用者意外地使用了不期望的默认参数值
// 了解默认的函数行为，包括默认构造函数、默认拷贝构造函数、默认赋值操作符和默认析构函数等
// 避免在析构函数中抛出异常，因为这可能会导致程序崩溃或者资源泄漏等问题
// 尽量将类的数据成员声明为私有，然后提供公共的成员函数来访问和修改这些数据成员
// 在函数中尽量使用const来修饰参数和返回值，以便更好地表明函数的行为和语义
// 了解C++对象模型，包括虚函数表、多重继承、虚继承等概念
// 在重载运算符时遵循约定，以便更好地表达运算符的语义和行为
// 避免将异常传递到边界，因为这可能会导致程序崩溃或者资源泄漏等问题

// 三、难点归纳：
// 对象的构造和析构：需要深入理解对象的生命周期和管理内存的技巧
// 拷贝控制：包括拷贝构造函数、赋值操作符和析构函数，需要理解拷贝控制的概念和实现方式，以便更好地管理对象的拷贝和销毁
// 类继承和多态：面向对象编程的核心概念，需要深入理解虚函数、虚继承、多重继承等概念
// 模板编程：需要深入理解模板的概念和使用方法，以便编写出具有高度通用性和可重用性的代码
// 异常处理：需要理解异常的概念和处理方式，以便编写出具有高度健壮性和可靠性的代码
// 运算符重载：需要掌握正确使用运算符重载的方式，以便更好地表达运算符的语义和行为
// STL和泛型编程：需要熟练掌握STL中的容器、算法和迭代器等概念和使用方法，以便编写出高效、可维护和可重用的代码



/*****************************more effective**************************************/
// 序言
// 指针与引用









/*****************************modern effective************************************/
// auto无法推导出整个模板T，但可以推导出std::initializer_list<T>,
// C++14：decltype(auto) 	
// C++11：auto...->decltype(...)





/*****************************effective STL************************************/






