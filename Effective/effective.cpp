

/**************************************effictive*******************************/
// 一、Contents (DialyLog):
// 优秀的异常设计(客户端操作/非析构函数 + 析构函数捕获(失败将回到终止或吞咽))
// 派生类与基类转换问题(显式与隐式(dynamic_cast横/侧向转换规则)、指针与引用、智能指针)
// RAII资源管理类(智能指针+析构释放)：api访问原始资源(显式转换更安全，隐式转换更方便客户端)
// 引用传递机制(切割问题)
// 延后变量定义至明显意义初值，避免无意义默认构造
// 模板代码膨胀问题及解决方案、编译依存性
// 遮掩继承条款
// 区分接口继承与实现继承(pure/impure/non_virtual,NVI手法)
// 深入了解non_virtual函数(不要重新定义)
// 静态绑定与动态绑定
// classes(显式接口+运行期多态)、templates(隐式接口+编译期多态)
// 整合重载技术使在编译期间执行if...else测试
// 模板元编程(结构体递归求阶乘)

typedef void (*new_handler)();
new_handler set_new_handler(new handler p)	throw ();	//返回函数的函数

// 二、易错点归纳：
// 尽量使用const、enum、inline等代替#define，因为#define可能会导致一些不可预期的问题，比如符号重定义、类型不匹配等问题
// 构造函数的实参可以通过隐式类型转换来匹配对应的形参类型。但如果构造函数的形参不是const引用类型，那么这种隐式类型转换可能会导致不必要的构造函数调用和内存分配
// 在函数声明中，应该尽量避免使用与内置类型等效的默认参数，因为这样可能会导致调用者意外地使用了不期望的默认参数值
// 了解默认的函数行为，包括默认构造函数、默认拷贝构造函数、默认赋值操作符和默认析构函数等
// 避免在析构函数中抛出异常，因为这可能会导致程序崩溃或者资源泄漏等问题
// 尽量将类的数据成员声明为私有，然后提供公共的成员函数来访问和修改这些数据成员
// 在函数中尽量使用const来修饰参数和返回值，以便更好地表明函数的行为和语义
// 了解C++对象模型，包括虚函数表、多重继承、虚继承等概念
// 在重载运算符时遵循约定，以便更好地表达运算符的语义和行为
// 避免将异常传递到边界，因为这可能会导致程序崩溃或者资源泄漏等问题

// 三、难点归纳：
// 对象的构造和析构：需要深入理解对象的生命周期和管理内存的技巧
// 拷贝控制：包括拷贝构造函数、赋值操作符和析构函数，需要理解拷贝控制的概念和实现方式，以便更好地管理对象的拷贝和销毁
// 类继承和多态：面向对象编程的核心概念，需要深入理解虚函数、虚继承、多重继承等概念
// 模板编程：需要深入理解模板的概念和使用方法，以便编写出具有高度通用性和可重用性的代码
// 异常处理：需要理解异常的概念和处理方式，以便编写出具有高度健壮性和可靠性的代码
// 运算符重载：需要掌握正确使用运算符重载的方式，以便更好地表达运算符的语义和行为
// STL和泛型编程：需要熟练掌握STL中的容器、算法和迭代器等概念和使用方法，以便编写出高效、可维护和可重用的代码



/*****************************more effective**************************************/
//当知道必须指向一个对象并且不想改变其指向时，或者在重载操作符并为防止不必要的语义误解时，不应该使用指针
//让编译器进行隐式类型转换所造成的弊端要大于它所带来的好处，所以除非确实需要，不要定义类型转换函数
//智能指针在捕获异常上的优越性，资源应该被封装在一个对象里，遵循这个规则通常就能避免在存在异常环境里发生资源泄漏
//C++仅仅能删除被完全构造的对象(new操作可能没有成功完成)
class BookEntry { 
public:   
	...                                      
private:   
	...   
	const auto_ptr<Image> theImage;          // auto_ptr 对象 
	const auto_ptr<AudioClip> theAudioClip;  
};

BookEntry::BookEntry(const string& name, const string& address, const string& imageFileName, const string& audioClipFileName) 
	: theName(name), theAddress(address), 
	theImage(mageFileName != "" ? new Image(imageFileName) : 0), 
	theAudioClip(audioClipFileName != "" ? new AudioClip(audioClipFileName) : 0) 
{   
}	

BookEntry::~BookEntry() {}    //// 用对应的智能指针对象替代指针成员变量，就可以防止构造函数在存在异常时发生资源泄漏，同时不用手工在析构函数中释放资源








/*****************************modern effective************************************/
// auto无法推导出整个模板T，但可以推导出std::initializer_list<T>,
// C++14：decltype(auto) 	
// C++11：auto...->decltype(...)





/*****************************effective STL************************************/






