

/*****************************effictive*************************/
// 优秀的异常设计(客户端操作/非析构函数 + 析构函数捕获(失败将回到终止或吞咽))
// 派生类与基类转换问题(显式与隐式(dynamic_cast横/侧向转换规则)、指针与引用、智能指针)
// map、unordered_map应用场景：map:有序红黑树,迭代器算法,性能好;unordered_map:无序哈希表,擅长CRUD,可能导致哈希冲突
// RAII资源管理类(智能指针+析构释放)：api访问原始资源(显式转换更安全，隐式转换更方便客户端)
// 引用传递机制(切割问题)
// 延后变量定义至明显意义初值，避免无意义默认构造
// 模板代码膨胀问题及解决方案、编译依存性
// 遮掩继承条款
// 区分接口继承与实现继承(pure/impure/non_virtual,NVI手法)
// 深入了解non_virtual函数(不要重新定义)
// 静态绑定与动态绑定
// classes(显式接口+运行期多态)、templates(隐式接口+编译期多态)
// 整合重载技术使在编译期间执行if...else测试
// 模板元编程(结构体递归求阶乘)
typedef void (*new_handler)();
new_handler set_new_handler(new handler p)	throw ();	//返回函数的函数


/*****************************more effective***********************************/






/*****************************modern effective************************************/

// auto无法推导出整个模板T，但可以推导出std::initializer_list<T>,
// C++14：decltype(auto) 	
// C++11：auto...->decltype(...)

